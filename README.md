# Queue
Java program to Implement a queue using singly linked list public class QueueLL



ðŸ”— Queue Implementation using Singly Linked ListThis project provides a straightforward implementation of a Queue data structure in Java using a Singly Linked List. A Queue is a First-In, First-Out (FIFO) data structure, meaning the element added first will be the one removed first.ðŸ’¡ OverviewThe core of this implementation involves two classes:Node: Represents an individual element in the linked list, containing the data and a reference to the next node.queueType: Implements the Queue logic, managing the front and rear pointers of the linked list to enforce FIFO behavior.ðŸš€ Getting StartedPrerequisitesJava Development Kit (JDK) installed.A Java IDE (like IntelliJ, Eclipse) or a text editor and command line.ExecutionSave the code as a single Java file (e.g., QueueLL.java).Compile and run the main class QueueLL.The main method demonstrates the usage of the queue by adding elements and then continuously deleting and printing the front element until the queue is empty.Bash# Example compilation and run
javac QueueLL.java
java QueueLL
Expected Output********************
1 <-- 2 <-- 3 <-- 4 <--  End of Queue
********************
âš™ï¸ Class and Method Details1. Node ClassThis is a simple helper class used by the queueType class.FieldDescriptionint dataHolds the integer value of the node.Node nextPointer to the next node in the sequence.2. queueType ClassThis class manages the queue's state and operations using two key pointers: queueFront (for deletion) and queueRear (for insertion).MethodDescriptionQueue OperationqueueType()Default constructor; initializes both queueFront and queueRear to null.InitializerisEmptyQueue()Checks if the queue is empty by verifying if queueFront is null.Status CheckisFullQueue()Always returns false. In a linked list implementation, the queue is theoretically never full (limited only by system memory).Status CheckaddQueue(int x)Enqueue operation. Inserts a new element at the queueRear pointer. Updates queueRear to the new node.Insertion (FIFO)deleteQueue()Dequeue operation. Removes the element at the queueFront pointer and updates queueFront to the next node.Deletion (FIFO)front()Returns the data of the element currently pointed to by queueFront without removing it.Peek (Front)back()Returns the data of the element currently pointed to by queueRear.Peek (Rear)ðŸ› ï¸ Implementation DetailsThe core of the FIFO behavior is maintained by how addQueue and deleteQueue operate:addQueue (Enqueue): New nodes are always added by changing queueRear.next and then moving the queueRear pointer to the newly added node.deleteQueue (Dequeue): Elements are removed by simply advancing the queueFront pointer to the next node (this.queueFront = this.queueFront.next;), effectively dropping the reference to the first element.This dual-pointer approach ensures $O(1)$ (constant time) complexity for both insertion and deletion operations.
